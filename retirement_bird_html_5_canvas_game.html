<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Retirement Bird â€” Powered by 401JK</title>
  <style>
    :root{ --gold:#ffd166; --ink:#fff; --panel:#13151a; --bg:#0b1220; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:var(--bg);font-family:System-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;color:var(--ink)}

    header{padding:12px 16px;text-align:center}
    header h1{margin:0;font-size:clamp(18px,4vw,24px)}

    .wrap{width:100%;max-width:min(92vw,720px);margin:0 auto;padding:0 12px 16px}

    /* Game area */
    #game{position:relative;width:100%;aspect-ratio:9/16;background:#101622;border:3px solid var(--gold);border-radius:16px;overflow:hidden;box-shadow:0 10px 30px rgba(0,0,0,.45)}
    canvas{width:100%;height:100%;display:block;background:#000}

    /* HUD */
    .hud{position:absolute;top:8px;left:0;right:0;z-index:2;display:flex;gap:8px;justify-content:center;font-weight:800;font-size:clamp(12px,3.2vw,14px);text-shadow:0 1px 0 #000}
    .pill{padding:6px 10px;border-radius:999px;background:rgba(255,255,255,.12);border:1px solid rgba(255,255,255,.15)}

    /* Floating promo */
    .promo{position:absolute;bottom:10px;left:50%;transform:translateX(-50%);background:var(--gold);color:#111;padding:6px 12px;border-radius:999px;font-size:clamp(12px,3.2vw,13px);font-weight:900;cursor:pointer;z-index:2}

    /* Controls (kept simple) */
    .controls{margin:10px 0 0;display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .btn{appearance:none;border:none;cursor:pointer;padding:10px 14px;border-radius:12px;font-weight:800;font-size:clamp(14px,3.8vw,16px)}
    .btn.primary{background:var(--gold);color:#111}
    .btn.ghost{background:#1f2937;color:#e5e7eb;border:1px solid rgba(255,255,255,.12)}

    /* Game Over overlay */
    .overlay{position:absolute;inset:0;display:none;place-items:center;background:rgba(0,0,0,.55);z-index:3}
    .overlay .card{background:var(--panel);border:2px solid var(--gold);border-radius:16px;padding:14px;width:min(92%,420px);box-shadow:0 12px 32px rgba(0,0,0,.55)}
    .overlay h2{margin:6px 0 2px;font-size:clamp(18px,4.5vw,22px);color:var(--gold)}
    .overlay p{margin:0 0 10px;font-size:clamp(13px,3.5vw,15px);opacity:.95}
    .overlay p.statsLine{display:flex;flex-wrap:wrap;gap:6px;align-items:center;justify-content:center;text-align:center}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px}
    .row .btn{width:100%}

    @media (min-width:640px){.wrap{max-width:520px}}
    @media (min-width:900px){.wrap{max-width:620px}}
  </style>
</head>
<body data-rb-authenticated="false" data-rb-stats-url="" data-rb-auth-token="" data-rb-user-id="">
  <header class="wrap">
    <h1><img src="https://401jk.fun/logo.png" alt="401JK Logo" style="height:1.4em;vertical-align:middle"> Retirement Bird Â· 401JK Meme Edition</h1>
  </header>
  <main class="wrap">
    <section id="game">
      <canvas id="c"></canvas>

      <!-- Game Over Overlay -->
      <div id="over" class="overlay" aria-hidden="true">
        <div class="card" role="dialog" aria-modal="true" aria-labelledby="overTitle">
          <img id="overChar" alt="401JK Character" src="https://401jk.fun/img/char.png" style="width:100%;max-height:140px;object-fit:contain;border-radius:10px;display:block;margin:0 auto 6px">
          <h2 id="overTitle">Game Over</h2>
          <p class="statsLine">Score <span id="overScore">0</span> Â· Best <span id="overBest">0</span> Â· Games <span id="overGames">0</span></p>
          <div class="row">
            <a id="xShare" class="btn primary" href="#" target="_blank" rel="noopener">Share on X</a>
            <a id="tgShare" class="btn primary" href="#" target="_blank" rel="noopener">Telegram</a>
          </div>
          <div class="row">
            <a id="overCta" class="btn primary" href="#" target="_blank" rel="noopener">Buy 401JK</a>
            <button id="retryBtn" class="btn ghost">Retry</button>
          </div>
        </div>
      </div>

      <div class="hud">
        <div class="pill">Score: <span id="score">0</span></div>
        <div class="pill">Best: <span id="best">0</span></div>
        <div class="pill">Games: <span id="games">0</span></div>
      </div>
      <div id="promo" class="promo">ðŸ’¸ Meme your retirement â†’ 401JK</div>
    </section>

    <div class="controls">
      <button id="shareBtn" class="btn ghost">Share</button>
      <a id="ctaBtn" class="btn primary" href="#" target="_blank" rel="noopener">Buy 401JK</a>
    </div>

    <p style="opacity:.9;font-size:clamp(12px,3.2vw,14px);margin:10px 0 0">Tap / Click to flap. Dodge Fees, collect $401JK. <br><img src="https://401jk.fun/meme.png" alt="401JK Meme" style="max-width:100%;border-radius:12px;margin-top:8px"></p>
  </main>

<script>
'use strict';
(function(){
  const runtimeConfig = getRuntimeConfig();
  const PROMO_BASE = runtimeConfig.promoUrl;

  // DOM refs
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('best');
  const gamesEl = document.getElementById('games');
  const ctaBtn = document.getElementById('ctaBtn');
  const promo = document.getElementById('promo');
  const shareBtn = document.getElementById('shareBtn');
  const over = document.getElementById('over');
  const overScore = document.getElementById('overScore');
  const overBest = document.getElementById('overBest');
  const overGames = document.getElementById('overGames');
  const retryBtn = document.getElementById('retryBtn');
  const xShare = document.getElementById('xShare');
  const tgShare = document.getElementById('tgShare');
  const overCta = document.getElementById('overCta');

  const storage = initStorage();
  const STORAGE_KEY = 'rb_stats_v1';
  const LEGACY_KEY = 'best401';
  const storedStats = readStoredStats();
  let best = storedStats.best;
  let games = storedStats.games;
  let lastRoundScore = 0;

  const statsBridge = createStatsBridge(runtimeConfig);

  const IMG_LOGO_SRC = 'https://401jk.fun/img/logo.png';
  const IMG_WALL_SRC = 'https://401jk.fun/img/wall.png';
  const imgLogo = new Image(); imgLogo.src = IMG_LOGO_SRC;
  const imgWall = new Image(); imgWall.src = IMG_WALL_SRC;

  let W=0, H=0, DPR=1; let CSSW=0, CSSH=0; const DRAG=2.5;
  let gravity=1500, flapImpulse=-560, scroll=160;
  let pipeGap=0, pipeW=0, spawnDist=0;

  let bird, pipes, score = 0, state = 'ready';
  let lastT = 0;

  if(ctaBtn){ ctaBtn.href = PROMO_BASE; }
  if(overCta){ overCta.href = PROMO_BASE; }

  statsBridge.load().then(remote => {
    if(!remote) return;
    let changed = false;
    if(remote.best > best){ best = remote.best; changed = true; }
    if(remote.games > games){ games = remote.games; changed = true; }
    if(changed){
      persistStatsLocal({ best, games });
      updateHud();
      if(state === 'over') refreshOverlayStats();
    }
  });

  function fit(){
    DPR = Math.min(2, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    CSSW = Math.max(200, rect.width);
    CSSH = Math.max(200, rect.height);
    W = Math.floor(CSSW * DPR);
    H = Math.floor(CSSH * DPR);
    canvas.width = W; canvas.height = H; ctx.setTransform(DPR,0,0,DPR,0,0);

    pipeGap   = Math.round(CSSH * 0.38);
    pipeW     = Math.round(CSSW * 0.16);
    spawnDist = Math.round(CSSW * 0.55);

    let g = 2.0 * CSSH;
    let flap = -0.70 * CSSH;
    let scr = 0.30 * CSSW;
    if(CSSH < 520){ flap = -0.60 * CSSH; g = 1.9 * CSSH; scr = 0.28 * CSSW; }
    if(CSSH < 420){ flap = -0.55 * CSSH; g = 1.85 * CSSH; scr = 0.26 * CSSW; }

    gravity = g; flapImpulse = flap; scroll = scr;

    if(bird){ bird.r = Math.max(10, Math.round(CSSW * 0.04)); }
  }
  new ResizeObserver(fit).observe(canvas);

  function reset(){
    score = 0;
    lastRoundScore = 0;
    state = 'ready';
    pipes = [];
    lastT = 0;
    hideOverlay();
    bird = { x: Math.round(CSSW*0.22), y: Math.round(CSSH*0.5), vy: 0, r: Math.max(10, Math.round(CSSW*0.04)) };
    updateHud();
  }

  function flapBird(){
    if(state==='ready') state='play';
    if(state==='play') bird.vy = flapImpulse;
  }

  canvas.addEventListener('pointerdown', flapBird, {passive:true});

  ctaBtn.onclick = () => window.open(PROMO_BASE, '_blank');
  promo.onclick = () => window.open(PROMO_BASE, '_blank');
  shareBtn.onclick = () => {
    const shareScore = state === 'over'
      ? lastRoundScore
      : (score > 0 ? score : best);
    const shareStats = { score: shareScore, best, games };
    const links = buildShareUrls(shareStats);
    const xFirst = /iphone|android|mobile/i.test(navigator.userAgent);
    window.open(xFirst ? links.x : links.tg, '_blank');
  };

  function addPipe(){
    const top = Math.random() * (CSSH * 0.45) + CSSH * 0.15;
    const gap = Math.max(pipeGap*0.85, pipeGap - Math.max(0, score)*3);
    pipes.push({ x: canvas.clientWidth, y: top, gap, scored: false });
  }

  function update(dt){
    if(state !== 'play') return;

    bird.vy += gravity * dt;
    bird.vy += -DRAG * bird.vy * dt;
    if(bird.vy < -CSSH) bird.vy = -CSSH;
    bird.y  += bird.vy * dt;

    if(bird.y - bird.r < 0 || bird.y + bird.r > CSSH) return gameover();

    if(pipes.length === 0 || pipes[pipes.length-1].x < canvas.clientWidth - spawnDist) addPipe();

    for(const p of pipes){ p.x -= scroll * dt; }
    pipes = pipes.filter(p => p.x + pipeW > 0);

    for(const p of pipes){
      if(!p.scored && p.x + pipeW < bird.x){
        score++;
        p.scored = true;
        updateHud();
      }
      const inX = bird.x + bird.r > p.x && bird.x - bird.r < p.x + pipeW;
      const hitTop = bird.y - bird.r < p.y;
      const hitBottom = bird.y + bird.r > p.y + p.gap;
      if(inX && (hitTop || hitBottom)) return gameover();
    }
  }

  function gameover(){
    if(state === 'over') return;
    state = 'over';
    lastRoundScore = score;
    games = sanitizeStat(games, 0) + 1;
    if(score > best) best = score;
    persistStatsLocal({ best, games });
    updateHud();
    refreshOverlayStats();
    applyShareLinks({ score: lastRoundScore, best, games });
    if(overCta) overCta.href = PROMO_BASE;
    showOverlay();
    statsBridge.push({ score: lastRoundScore, best, games }).then(remote => {
      if(!remote) return;
      let changed = false;
      if(remote.best > best){ best = remote.best; changed = true; }
      if(remote.games > games){ games = remote.games; changed = true; }
      if(changed){
        persistStatsLocal({ best, games });
        updateHud();
        if(state === 'over') refreshOverlayStats();
        applyShareLinks({ score: lastRoundScore, best, games });
      }
    });
  }

  function updateHud(){
    scoreEl.textContent = String(score);
    bestEl.textContent = String(best);
    if(gamesEl) gamesEl.textContent = String(games);
  }

  function refreshOverlayStats(){
    overScore.textContent = String(lastRoundScore);
    overBest.textContent = String(best);
    overGames.textContent = String(games);
  }

  function hideOverlay(){
    over.style.display = 'none';
    over.setAttribute('aria-hidden','true');
  }

  function showOverlay(){
    over.style.display = 'grid';
    over.setAttribute('aria-hidden','false');
  }

  function applyShareLinks(stats){
    const links = buildShareUrls(stats);
    xShare.href = links.x;
    tgShare.href = links.tg;
  }

  function draw(){
    const w = canvas.clientWidth, h = canvas.clientHeight;
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0,'#0d274a'); g.addColorStop(1,'#082235');
    ctx.fillStyle = g; ctx.fillRect(0,0,w,h);

    if(imgWall && imgWall.complete && imgWall.naturalWidth){
      const tile = Math.max(96, Math.floor(w*0.18));
      ctx.save(); ctx.globalAlpha = 0.08;
      for(let y=-tile; y<h+tile; y+=tile){
        for(let x=-tile; x<w+tile; x+=tile){ ctx.drawImage(imgWall, x, y, tile, tile); }
      }
      ctx.restore();
    }

    const topGrad = ctx.createLinearGradient(0,0,0,Math.max(40,h*0.2));
    topGrad.addColorStop(0,'#ef476f'); topGrad.addColorStop(1,'#9d2a46');
    const bottomGrad = ctx.createLinearGradient(0,h*0.6,0,h);
    bottomGrad.addColorStop(0,'#06d6a0'); bottomGrad.addColorStop(1,'#056e58');

    for(const p of pipes){
      ctx.fillStyle = topGrad; ctx.fillRect(p.x, 0, pipeW, p.y);
      ctx.fillStyle = bottomGrad; ctx.fillRect(p.x, p.y + p.gap, pipeW, h - (p.y + p.gap));
      ctx.save(); ctx.fillStyle='rgba(255,255,255,.85)'; ctx.font='bold 10px system-ui, sans-serif'; ctx.textAlign='center';
      ctx.translate(p.x + pipeW/2, p.y/2); ctx.rotate(-Math.PI/2); ctx.fillText('FEES', 0, 0); ctx.restore();
    }

    ctx.fillStyle = '#ffd166';
    ctx.beginPath(); ctx.arc(bird.x, bird.y, bird.r, 0, Math.PI*2); ctx.fill();

    if(imgLogo && imgLogo.complete && imgLogo.naturalWidth && w>360){
      const lw = Math.min(140, Math.floor(w*0.35));
      const lh = Math.floor(lw * (imgLogo.naturalHeight / imgLogo.naturalWidth));
      ctx.save(); ctx.globalAlpha=0.12; ctx.drawImage(imgLogo, 8, 8, lw, lh); ctx.restore();
    }

    if(state==='ready'){
      ctx.fillStyle='#fff'; ctx.font='bold 16px system-ui, sans-serif';
      ctx.fillText('Tap to Start', w*0.35, h*0.46);
    }
  }

  function loop(t){
    if(!lastT) lastT = t;
    const dt = Math.min(0.033, (t - lastT) / 1000);
    lastT = t;
    update(dt); draw(); requestAnimationFrame(loop);
  }

  retryBtn.addEventListener('click', () => { reset(); });

  fit(); reset(); requestAnimationFrame(loop);

  (function runTests(){
    try{
      fit(); console.assert(CSSW>0 && CSSH>0, 'fit -> CSS dims > 0');
      reset(); console.assert(state==='ready','reset -> state=ready');
      pipes=[]; addPipe(); console.assert(pipes.length===1,'addPipe -> one pipe');
      console.assert(typeof pipes[0].gap==='number' && pipes[0].gap>0,'pipe has gap');
      const absFlap = Math.abs(flapImpulse); console.assert(absFlap < CSSH*0.8 && absFlap > CSSH*0.15, 'flapImpulse sane');
      const y0 = bird.y; flapBird(); update(0.2); const dy = Math.abs(bird.y - y0); console.assert(dy < CSSH*0.25, 'rise < 25% height over 200ms');
      const savedPush = statsBridge.push;
      const savedBest = best; const savedGames = games;
      try{
        statsBridge.push = () => Promise.resolve(null);
        score=3; gameover();
        console.assert(xShare.href.includes('twitter.com/intent'),'xShare link built');
        console.assert(tgShare.href.includes('t.me/share/url'),'tgShare link built');
      }finally{
        best = savedBest; games = savedGames; persistStatsLocal({ best, games });
        statsBridge.push = savedPush; reset();
      }
      console.assert(getComputedStyle(over).display==='none','overlay hidden after reset');
      console.log('%cSelf-tests passed','color:#ffd166');
    }catch(e){ console.error('self-tests failed', e); }
  })();

  function initStorage(){
    try{
      const ls = window.localStorage;
      const probe = '__rb_probe__';
      ls.setItem(probe, probe);
      ls.removeItem(probe);
      return ls;
    }catch(err){
      console.warn('localStorage unavailable, stats will be temporary.', err);
      return null;
    }
  }

  function readStoredStats(){
    if(!storage) return { best:0, games:0 };
    try{
      const raw = storage.getItem(STORAGE_KEY);
      if(raw){
        const parsed = JSON.parse(raw);
        const best = sanitizeStat(parsed.best, 0);
        const games = sanitizeStat(parsed.games, 0);
        return { best, games };
      }
    }catch(err){
      console.warn('Unable to parse stored stats.', err);
    }
    try{
      const legacy = storage.getItem(LEGACY_KEY);
      const best = sanitizeStat(legacy, 0);
      return { best, games:0 };
    }catch(err){
      if(err) console.warn('Unable to read legacy best score.', err);
    }
    return { best:0, games:0 };
  }

  function persistStatsLocal(stats){
    if(!storage) return;
    const payload = {
      best: sanitizeStat(stats.best, 0),
      games: sanitizeStat(stats.games, 0)
    };
    try{
      storage.setItem(STORAGE_KEY, JSON.stringify(payload));
      storage.setItem(LEGACY_KEY, String(payload.best));
    }catch(err){
      console.warn('Unable to persist stats locally.', err);
    }
  }

  function createStatsBridge(config){
    const statsUrl = config.statsUrl;
    const loginCheck = () => {
      if(typeof config.isLoggedIn === 'function'){
        try{ return !!config.isLoggedIn(); }
        catch(err){ console.warn('isLoggedIn() threw, assuming logged out.', err); return false; }
      }
      if(typeof config.loggedIn === 'boolean') return config.loggedIn;
      if(typeof config.loggedIn === 'string'){
        if(config.loggedIn === 'true') return true;
        if(config.loggedIn === 'false') return false;
      }
      if(config.authToken) return true;
      return false;
    };

    function buildHeaders(includeJson){
      const headers = { Accept: 'application/json' };
      if(config.extraHeaders) Object.assign(headers, config.extraHeaders);
      if(config.authToken) headers.Authorization = config.authToken;
      if(config.csrfToken) headers['X-CSRF-Token'] = config.csrfToken;
      if(includeJson) headers['Content-Type'] = 'application/json';
      return headers;
    }

    async function load(){
      if(!statsUrl || !loginCheck()) return null;
      try{
        const resp = await fetch(statsUrl, { method: 'GET', credentials: 'include', headers: buildHeaders(false) });
        if(!resp.ok) throw new Error(`stats GET failed with ${resp.status}`);
        const data = await resp.json();
        return {
          best: sanitizeStat(data.bestScore ?? data.best ?? data.highScore, best),
          games: sanitizeStat(data.gamesPlayed ?? data.games ?? data.playCount, games)
        };
      }catch(err){
        console.warn('Unable to load remote stats.', err);
        return null;
      }
    }

    async function push(payload){
      if(!statsUrl || !loginCheck()) return null;
      try{
        const resp = await fetch(statsUrl, {
          method: 'POST',
          credentials: 'include',
          headers: buildHeaders(true),
          body: JSON.stringify({
            score: payload.score,
            bestScore: payload.best,
            gamesPlayed: payload.games,
            userId: config.userId || undefined
          })
        });
        if(resp.status === 204) return null;
        if(!resp.ok) throw new Error(`stats POST failed with ${resp.status}`);
        const data = await resp.json().catch(() => null);
        if(!data) return null;
        return {
          best: sanitizeStat(data.bestScore ?? data.best ?? data.highScore ?? payload.best, payload.best),
          games: sanitizeStat(data.gamesPlayed ?? data.games ?? data.playCount ?? payload.games, payload.games)
        };
      }catch(err){
        console.warn('Unable to persist stats to backend.', err);
        return null;
      }
    }

    return { load, push };
  }

  function buildShareUrls(stats){
    const safeStats = {
      score: sanitizeStat(stats.score, 0),
      best: sanitizeStat(stats.best, 0),
      games: sanitizeStat(stats.games, 0)
    };
    const text = pickQuip(safeStats);
    const encodedUrl = encodeURIComponent(PROMO_BASE);
    const encodedText = encodeURIComponent(text);
    return {
      text,
      x: `https://twitter.com/intent/tweet?text=${encodedText}&url=${encodedUrl}`,
      tg: `https://t.me/share/url?url=${encodedUrl}&text=${encodedText}`
    };
  }

  function pickQuip(stats){
    const quips = [
      `I retired a bird before my portfolio. Score ${stats.score}. #401JK`,
      `Just scored ${stats.score} in Retirement Bird. Financial advice: flap early, sell never. #401JK`,
      `My pension is a meme and my bird can fly. Score ${stats.score}. #401JK`
    ];
    if(stats.games > 1){
      quips.push(`Run ${stats.games} and counting. Best ${stats.best}, latest ${stats.score}. #401JK`);
    }else if(stats.best > stats.score){
      quips.push(`Best ${stats.best}, but the latest round ended at ${stats.score}. Back to the grind! #401JK`);
    }
    return quips[Math.floor(Math.random()*quips.length)];
  }

  function sanitizeStat(value, fallback){
    const num = Number(value);
    if(!Number.isFinite(num) || num < 0) return fallback ?? 0;
    return Math.floor(num);
  }

  function getRuntimeConfig(){
    const dataset = document.body?.dataset ?? {};
    const globalCfg = (typeof window !== 'undefined' && window.RB_CONFIG && typeof window.RB_CONFIG === 'object') ? window.RB_CONFIG : {};
    const coalesce = (...values) => {
      for(const value of values){
        if(value === undefined || value === null) continue;
        if(typeof value === 'string' && value.trim() === '') continue;
        return value;
      }
      return undefined;
    };
    const parseBool = (value) => {
      if(typeof value === 'boolean') return value;
      if(typeof value === 'string'){
        if(value === 'true') return true;
        if(value === 'false') return false;
      }
      return undefined;
    };
    const extraHeaders = typeof globalCfg.extraHeaders === 'object' && globalCfg.extraHeaders
      ? globalCfg.extraHeaders
      : null;

    return {
      promoUrl: coalesce(globalCfg.promoUrl, dataset.rbPromoUrl, 'https://dexscreener.com/solana/Cz7LGKdZPpAxonXx23ZYPW3RtDQvjcf17ZDCZEzFpump'),
      statsUrl: coalesce(globalCfg.statsUrl, dataset.rbStatsUrl),
      authToken: coalesce(globalCfg.authToken, dataset.rbAuthToken),
      csrfToken: coalesce(globalCfg.csrfToken, dataset.rbCsrfToken, dataset.rbCsrf),
      userId: coalesce(globalCfg.userId, dataset.rbUserId),
      extraHeaders,
      loggedIn: coalesce(parseBool(globalCfg.loggedIn), parseBool(dataset.rbAuthenticated)),
      isLoggedIn: typeof globalCfg.isLoggedIn === 'function' ? globalCfg.isLoggedIn : null
    };
  }
})();
</script>
</body>
</html>
